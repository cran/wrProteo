#' Read csv or txt files exported from MS-Angel and Proline
#'
#' Quantification results form \href{https://www.maxquant.org/}{MaxQuant} can be read using this function and relevant information extracted. 
#' The final output is a list containing 3 elements: \code{$annot}, \code{$abund} and optional \code{$quant}, or returns data.frame with entire content of file if \code{separateAnnot=FALSE}.
#' This function has been developed using MaxQuant version 1.6.10.x, the format of resulting file 'proteinGroups.txt' is typically well conserved.  
#' 
#' @param path (character) path of file to be read
#' @param fileName (character) name of file to be read (default 'proteinGroups.txt' as typically generated by MaxQuant in txt folder) 
#' @param normalizeMeth (character) normalization method (will be sent to  \code{\link[wrMisc]{normalizeThis}}) 
#' @param quantCol (character or integer) exact col-names, or if length=1 content of \code{quantCol} will be used as pattern to search among column-names for $quant using \code{grep} 
#' @param contamCol (character or integer, length=1) which columns should be used for contaminants marked by ProteomeDiscoverer
#' @param uniqPepPat (character, length=1) pattern to search for columns with unique (razor) peptides using \code{grep}, default set to read unique razor-peptides  
#' @param extrColNames (character) column names to be read (1: prefix for LFQ quantitation, default 'LFQ.intensity'; 2: column name for protein-IDs, default 'Majority.protein.IDs'; 3: column names of fasta-headers, default 'Fasta.headers', 4: column name for number of protein IDs matching, default 'Number.of.proteins')
#' @param specPref (character) prefix to identifiers allowing to separate i) recognize contamination database, ii) species of main identifications and iii) spike-in species
#' @param refLi (character or integer) custom specify which line of data is main species, if character (eg 'mainSpe'), the column 'SpecType' in $annot will be searched for exact match of the (single) term given
#' @param separateAnnot (logical) if \code{TRUE} output will be organized as list with \code{$annot}, \code{$abund} for initial/raw abundance values and \code{$quant} with final normalized quantitations
#' @param plotGraph (logical) optional plot vioplot of initial and normalized data (using \code{normalizeMeth}); alternatively the argument may contain numeric details that will be passed to \code{layout} when plotting
#' @param tit (character) custom title to plot
#' @param wex (numeric)  relative expansion factor of the violin in plot
#' @param silent (logical) suppress messages
#' @param callFrom (character) allow easier tracking of message produced
#' @return list with \code{$annot}, \code{$raw} for initial abundance values and \code{$quant} with final normalized quantitations, or returns data.frame with annot and quant if \code{separateAnnot=FALSE}
#' @seealso \code{\link[utils]{read.table}}, \code{\link[wrMisc]{normalizeThis}}) , \code{\link{readProlineFile}} 
#' @examples
#' path1 <- system.file("extdata",package="wrProteo")
#' # Here we'll load a short/trimmed example file (thus not MaxQuant default name) 
#' fiNa <- "proteinGroupsMaxQuantUps1.txt"
#' specPref1 <- c(conta="conta|CON_|LYSC_CHICK", mainSpecies="YEAST",spike="HUMAN_UPS")
#' dataMQ <- readMaxQuantFile(path1, file=fiNa, specPref=specPref1)
#' summary(dataMQ$quant)
#' matrixNAinspect(dataMQ$quant, gr=gl(3,3)) 
#' @export
readMaxQuantFile <- function(path,fileName="proteinGroups.txt",normalizeMeth="median", quantCol="LFQ.intensity",contamCol="Potential.contaminant",uniqPepPat="Razor...unique.peptides", refLi=NULL,
  extrColNames=c("Majority.protein.IDs","Fasta.headers","Number.of.proteins"), specPref=c(conta="conta|CON_|LYSC_CHICK",mainSpecies="OS=Homo sapiens"),
  tit=NULL, wex=1.6, separateAnnot=TRUE, plotGraph=TRUE, silent=FALSE,callFrom=NULL) {
  ## prepare  
  fxNa <- wrMisc::.composeCallName(callFrom,newNa="readMaxQuantFile")
  opar <- graphics::par(no.readonly=TRUE)      
  if(!file.exists(path)) stop(" Can't find path '",path,"'")
  chFi <- file.exists(file.path(path,fileName))
  if(!chFi) stop(" file  ",fileName," was NOT found in path ",path," !")
  if(length(unlist(sapply(c("\\.txt$","\\.txt.gz$"), grep, fileName))) <1) message(fxNa," Suspicious filename, this function was designed for reading tabulated text files produced by MaxQuant")
  chPa <- try(find.package("utils"),silent=TRUE)
  if("try-error" %in% class(chPa)) stop("package 'utils' not found ! Please install first")   
  ## initial read MaxQuant
  tmp <- utils::read.delim(file.path(path,fileName), stringsAsFactors=FALSE)
  ## check which columns can be extracted (for annotation)
  if(is.integer(contamCol)) contamCol <- colnames(tmp)[contamCol]   
  extrColNames <- union(extrColNames, contamCol)                     # add contamCol if not included in extrColNames
  chCol <- extrColNames %in% colnames(tmp)
  if(!any(chCol)) { extrColNames <- gsub("\\."," ",extrColNames)
    chCol <- extrColNames %in% colnames(tmp) }
  if(all(!chCol)) stop(" Problem locating annotation columns (",wrMisc::pasteC(extrColNames,quote="''"),")")
  if(any(!chCol) ) {
    if(!silent) message(fxNa," can't find columns ",wrMisc::pasteC(extrColNames[!chCol]),quote="'")
  }  
  if(any(!chCol)) stop("Can't find ANY columns of ",wrMisc::pasteC(extrColNames[!chCol],quote="'"))
  ## further extracting : quantitation  
  grepX <- function(x) grep(paste(x,"\\.",sep=""),colnames(tmp))
  useDCol <- if(length(quantCol)==1) grepX(quantCol) else unique(as.integer(sapply(quantCol,grepX)))
  if(length(useDCol) <1) stop("no columns matching terms from 'quantCol' found")
  MQdat <- as.matrix(tmp[,useDCol])
  quantColP <- NULL                  # initialize
  if(length(quantCol) <1) stop(" 'quantCol' must be provided !")
  if(length(quantCol) >1) { abund <- as.matrix(wrMisc::extrColsDeX(tmp, extrCol=quantCol, doExtractCols=TRUE, callFrom=fxNa))
  } else { chP <- substr(quantCol, nchar(quantCol), nchar(quantCol)) != "."
    quantColP <- quantCol
    quantCol <- if(chP) grep(paste(quantCol,"\\.",sep=""),colnames(tmp)) else grep(quantCol,colnames(tmp)) 
    chNa <- is.na(quantCol)
    if(all(chNa)) stop("Could not find any of the columns specified in argument 'quantCol' !")
    if(any(chNa)) { 
      if(!silent) message(fxNa," Could not find columns ",wrMisc::pasteC(quantCol[which(chNa)],quote="'")," .. omit")
      quantCol <- wrMisc::naOmit(quantCol)} 
    abund <- as.matrix(tmp[,quantCol]) }           # abundance val
  chNum <- is.numeric(abund)
  if(!chNum) {abund <- apply(tmp[,quantCol],2,wrMisc::convToNum,convert="allChar",callFrom=fxNa)}
  if(length(dim(abund)) <2 & !is.numeric(abund)) abund <- matrix(as.numeric(abund),ncol=ncol(abund),dimnames=dimnames(abund))
  colnames(abund) <- if(length(quantColP)==1) sub(paste(quantColP,"\\.",sep=""),"", colnames(abund)) else wrMisc::.trimFromStart(wrMisc::.trimFromEnd(colnames(abund)))
  ## convert 0 to NA
  abund[which(abund <= 0)] <- NA
  ## further extracting : annotation
  useACol <- wrMisc::naOmit(c(match(extrColNames,colnames(tmp)), grep(uniqPepPat,colnames(tmp)),grep("Peptides\\.",colnames(tmp))))
  MQann <- as.matrix(tmp[,useACol])
  if(length(specPref) <1) warning(fxNa," Trouble ahead: argument 'specPref' missing")
  specMQ0 <- list(conta=union(grep(specPref[1], MQann[,extrColNames[1]]), which(gsub(" ","",MQann[,contamCol[1]])=="+")),
    mainSpe= if(length(specPref) >1) grep(specPref[2],MQann[,extrColNames[2]]) else NULL, 
    species2= if(length(specPref) >2) grep(specPref[3], MQann[,extrColNames[1]]) else NULL,
    species3= if(length(specPref) >3) grep(specPref[4], MQann[,extrColNames[1]]) else NULL )
  if(length(specMQ0$mainSpe) <1) {
    specMQ0$mainSpe <- (1:nrow(tmp))[-1*unlist(specMQ0)]
    if(!silent) message(fxNa," Problem with 'mainSpecies' (none found), assuming that all ",length(specMQ0$mainSpe)," non-assigned proteins are 'mainSpecies' ")
  }   
  chTa <- table(table(unlist(specMQ0))) 
  specMQ <- rep(NA,nrow(abund))
  for(i in 1:length(specMQ0)) if(length(specMQ0[[i]]) >0) specMQ[specMQ0[[i]]] <- names(specMQ0)[i]
  if(!silent) { chSp <- sum(is.na(specMQ))
    if(chSp >0) message(fxNa," Note: ",chSp," unrecognized species")
    tab <- table(specMQ)
    tab <- rbind(names(tab),": ",tab,"  ")
    if(!silent) message("   by species : ",apply(tab,2,paste)) }             # all lines assigned   
  MQann <- cbind(SpecType=specMQ,MQann)                                          # better to name column 'species' ?? 
  ## split Annotation
  remHeader <- c("^conta\\|","^sp\\|") 
  MQan2 <- strsplit(sub(remHeader[1],"",sub(remHeader[2],"", MQann[,"Majority.protein.IDs"])),"\\|" )
  #MQan2 <- strsplit(MQann[,"Majority.protein.IDs"],"\\|" )
  MQanLe <- sapply(MQan2, length)
  MQan3 <- matrix(NA, nrow=nrow(MQann), ncol=2, dimnames=list(NULL,c("Accession","ProteinName")))
  chLe <- MQanLe==1
  if(any(chLe)) MQan3[which(chLe),1] <- unlist(MQan2[which(chLe)])
  chLe <- MQanLe==2
  if(any(chLe)) MQan3[which(chLe),] <- matrix(unlist(MQan2[which(chLe)]), ncol=2, byrow=TRUE)
  chLe <- MQanLe >2
  locAccNo <- function(x) {  # function to select AccessionNumner (eg P02768) and ProteinID (eg ALBU_HUMAN) after strsplit() of concatenated annotation
    accIn <- grep("^[[:upper:]]+[[:digit:]]+$", x)
    namId <- grep("[[:upper:]]_[[:upper:]]", x)
    useInd <- c(acc=if(length(accIn) >0) accIn[1] else NA, name=if(length(namId) >0) namId[1] else NA)
    chNA <- is.na(useInd)
    if(any(chNA)) useInd[which(chNA)] <- (1:length(x))[-1*wrMisc::naOmit(unique(c(namId,useInd)))][1:sum(chNA)]
    x[useInd] }
  if(any(chLe)) MQan3[which(chLe),] <-  t(sapply(MQan2[which(chLe)], locAccNo ))
  chSemc <- grep(";", MQan3[,2])                                  # look for semicolon separator  (eg "CATA_HUMAN_UPS;conta")
  if(length(chSemc) >0) MQan3[chSemc,2] <- sub(";[[:print:]]+","",MQan3[chSemc,2])       # remove all after semicolon (eg "CATA_HUMAN_UPS;conta")
  ## contaminants (fuse from column 'Potential.contaminant' and those found via specPref[1])
  contam <- rep(FALSE,nrow(MQann))
  if("Potential.contaminant" %in% colnames(MQann)) {chCo <- "+" %in% sub("^ ","",MQann[,"Potential.contaminant"])
    if(any(chCo)) contam[which(chCo)] <- TRUE }
  if(length(specMQ0$conta) >0) contam[specMQ0$conta] <- TRUE     ## from 'specPref' search
  if(length(specPref) >2) {
  }
  ## finalize annotation 
  MQann <- cbind(MQan3, Species=NA, Contam=contam, MQann)
  ## extract species according to custom search parameters 'specPref'
  chSpe1 <- MQann[,"SpecType"] =="mainSpe"
  if(!all(is.na(chSpe1)) & any(chSpe1)) MQann[which(chSpe1),"Species"] <- sub("OS=","",specPref[2])        #  or better search key-words ? 
  if(length(specPref) >2) {chSpe <- MQann[,"SpecType"] =="species2"
    if(!all(is.na(chSpe)) & any(chSpe)) MQann[which(chSpe),"Species"] <- sub("OS=","",specPref[3])}        #  or better search key-words ? 
  if(length(specPref) >3) {chSpe <- MQann[,"SpecType"] =="species3"
    if(!all(is.na(chSpe)) & any(chSpe)) MQann[which(chSpe),"Species"] <- sub("OS=","",specPref[4])}        #  or better search key-words ? 
  ## clean fasta entries: remove tailing punctuation or open backets (ie not closed) at end of fasta header
  cleanFasta <- TRUE        # clean fasta for artifacts of trunceted text trunct
  if(cleanFasta) { MQann[,"Fasta.headers"] <- sub("\\ +", "", MQann[,"Fasta.headers"])        # tailing space
    MQann[,"Fasta.headers"] <- sub("[[:punct:]]+","",MQann[,"Fasta.headers"])                 # tailing ';' ...    
    MQann[,"Fasta.headers"] <- sub(" \\([[:alpha:]]*$", "", MQann[,"Fasta.headers"])          # tailing open '('
  }
  
  ## now complete (overwrite) by info extracted from fasta : ' OS='
  chSpe <- grep(" OS=[[:upper:]][[:lower:]]+", MQann[,"Fasta.headers"])    
  if(length(chSpe) >0) MQann[chSpe,"Species"] <- sub(" \\(strain [[:print:]]+| [[:upper:]]{2}=[[:print:]]+", "", sub("[[:print:]]+OS=","",MQann[chSpe,"Fasta.headers"]) )
  ## remve text like 'XX=xxx' from [,"Species"] to remove strain name (most likely duplicating information)
  remStrainNo <- TRUE
  if(remStrainNo) MQann[chSpe,"Species"] <- sub(" [[:upper:]]{2}=[[:print:]]+", "", MQann[chSpe,"Species"])
  ## complete for eg  '... - Homo sapiens (Human).;'
  chSpe <- grep("\\- [[:upper:]][[:lower:]]+ [[:lower:]]+ \\([[:upper:]][[:lower:]]+\\)[[:punct:]]*$", MQann[,"Fasta.headers"])
  if(length(chSpe) >0) { tmp <- sub("\\ {0,1}[[:upper:]][[:lower:]]+ [[:lower:]]+ \\([[:upper:]][[:lower:]]+\\)[[:punct:]]*$", "", MQann[chSpe,"Fasta.headers"])
    MQann[chSpe,"Species"] <- sub(" \\([[:upper:]][[:lower:]]+\\)[[:punct:]]*", "",
      substr(MQann[chSpe,"Fasta.headers"], nchar(tmp)+1, nchar(MQann[chSpe,"Fasta.headers"]))) }
  MQann[,"Species"] <- sub("^ +","",MQann[,"Species"])                          # remove heading space
  ## check if some species may be fragment of longer one (aimed to remove artefact from truncated lines)
  allSpec <- wrMisc::naOmit(unique(MQann[,"Species"] ))
  chSpe <- lapply(allSpec, grep, allSpec)
  chTru <- sapply(chSpe, length) >1
  if(any(chTru)) for(i in which(chTru)) MQann[which(MQann[,"Species"] ==allSpec[i]),"Species"] <- allSpec[chSpe[[i]][which(chSpe[[i]] != i)]]

  ## look for unique col from $annot to use as rownames
  chAn <- colSums(apply(MQann[,c(1:min(ncol(MQann),5))], 2, duplicated), na.rm=TRUE)
  rownames(abund) <- rownames(MQann) <- if(any(chAn==0)) MQann[,which(chAn==0)[1]] else wrMisc::correctToUnique(MQann[,which.min(chAn)],callFrom=fxNa)  
  
  ## check for reference for normalization
  refLiIni <- refLi
  if(is.character(refLi) & length(refLi)==1) { refLi <- which(MQann[,"SpecType"]==refLi)
    if(length(refLi) <1) message(fxNa," could not find any protein matching argument 'refLi', ignoring ...") else {
      if(!silent) message(fxNa," normalize using subset of ",length(refLi))}}    # may be "mainSpe"
  if(length(refLi) <1) refLi <- NULL
  ## take log2 & normalize
  abundN <- wrMisc::normalizeThis(log2(abund), method=normalizeMeth, refLines=refLi, callFrom=fxNa) #

  ## plot distribution of intensities
  custLay <- NULL
  if(length(plotGraph) >0) {if(is.numeric(plotGraph)) {custLay <- plotGraph; plotGraph <- TRUE
    } else  {plotGraph <- as.logical(plotGraph[1])}}
  if(plotGraph){
    if(length(custLay) >0) graphics::layout(custLay) else graphics::layout(1:2)
    graphics::par(mar=c(3, 3, 3, 1))                          # mar: bot,le,top,ri
    chGr <- try(find.package("wrGraph"),silent=TRUE)
    chSm <- try(find.package("sm"),silent=TRUE)
    misPa <- c("try-error" %in% class(chGr),"try-error" %in% class(chSm))
    if(is.null(tit)) tit <- "MaxQuant Quantification "    
    titSu <- if(length(refLi) >0) paste0(c(" by ",if(length(refLiIni) >1) c(length(refLi)," selected lines") else c("'",refLiIni,"'")),collapse="")  else NULL
    if(any(misPa)) { 
      if(!silent) message(fxNa," missing package ",wrMisc::pasteC(c("wrGraph","sm")[which(misPa)],quoteC="'")," for drawing vioplots")
      ## wrGraph not available : simple boxplot  
      graphics::boxplot(log2(abund), main=paste(tit," (initial)"), las=1, outline=FALSE)
      graphics::abline(h=round(stats::median(log2(abund),na.rm=TRUE)) +(-1:1), lty=2, col=grDevices::grey(0.6)) 
      ## now normalized
      graphics::boxplot(abundN,main=paste(tit," (",normalizeMeth,"-normalized",titSu,")"), las=1, outline=FALSE)
      graphics::abline(h=round(stats::median(abundN,na.rm=TRUE)) +(-1:1), lty=2, col=grDevices::grey(0.6))
    } else {                                            # wrGraph and sm are available
      wrGraph::vioplotW(log2(abund), tit=paste(tit," (initial)"), wex=wex) 
      graphics::abline(h=round(stats::median(log2(abund),na.rm=TRUE)) +(-1:1), lty=2, col=grDevices::grey(0.6)) 
      ## now normalized
      wrGraph::vioplotW((abundN), tit=paste(tit," , ",normalizeMeth,"-normalized",titSu), wex=wex)
      graphics::abline(h=round(stats::median(abundN,na.rm=TRUE)) +(-1:1), lty=2, col=grDevices::grey(0.6))    
    }
    on.exit(graphics::par(opar)) }   #
  ## meta-data
  notes <- c( qmethod="MaxQuant", normalizeMeth=normalizeMeth, call=match.call(), created=as.character(Sys.time()), 
    wrProteo.version=utils::packageVersion("wrProteo"), machine=Sys.info()["nodename"])
  ## prepare for final output
  colnames(abundN) <- sub(paste(extrColNames[1],"\\.",sep="") ,"",sub("_[[:digit:]]","_",colnames(abund)))  
  if(separateAnnot) list(raw=abund, quant=abundN, annot=MQann, notes=notes) else data.frame(abund,MQann)
}  
  
