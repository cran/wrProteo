---
title: "Getting started with wrProteo"
author: Wolfgang Raffelsberger
date: '`r Sys.Date()`'
output:
  knitr:::html_vignette:
    toc: true
    fig_caption: yes
  pdf_document:
    highlight: null
    number_sections: no
vignette: >
  %\VignetteIndexEntry{wrProteoVignette1}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


## Introduction
This package contains a collection of various tools for Proteomics used at the [proteomics platform](http://proteomics.igbmc.fr/) of the [IGBMC](http://www.igbmc.fr/). 
To get started, we need to load the packages "[wrMisc](https://CRAN.R-project.org/package=wrMisc)" and 
this package ([wrProteo](https://CRAN.R-project.org/package=wrProteo)), both are available from CRAN.
The packages [wrGraph](https://CRAN.R-project.org/package=wrGraph) and [RColorBrewer](https://CRAN.R-project.org/package=RColorBrewer) get used internally by some of the functions from this package for (optional/improved) figures.
Furthermore, the Bioconductor package [limma](https://bioconductor.org/packages/release/bioc/html/limma.html) will be used internally for statistical testing

```{r, include = FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment = "#>")
```

```{r install, echo=TRUE, eval=FALSE}
## if you need to install the packages 'wrMisc','wrProteo' and 'wrGraph' from CRAN :
install.packages("wrMisc")
install.packages("wrProteo")
## The package 'wrGraph' is not obligatory, but it allows making better graphs
install.packages("wrGraph")
```


```{r setup, echo=FALSE, messages=FALSE, warnings=FALSE}
suppressPackageStartupMessages({
    library(wrMisc)
    library(wrProteo)
    library(knitr)
    library(rmarkdown) 
}) 
```

```{r setup2}
library("wrMisc")
library("wrProteo")
# This is wrProteo version no :
packageVersion("wrProteo")
```



## Calculating Molecular Masses From Composition Formulas

Please note that molecular masses may be given in two flavours : Monoisotopic mass and average mass.
Please refer eg to [Wikipedia: monoisotopic mass](https://en.wikipedia.org/wiki/Monoisotopic_mass) for details. 
Monoisotopic masses commonly are used in mass-spectrometry and will be used by default in this package.

Molecular (mono-isotopic) masses of the atomes used here were taken from [Unimod](http://www.unimod.org/masses.html). They can be easily updated, if in the future, (mono-isotopic) molecular masses will be determined with higher precision (ie more digits).


### Molecular masses based on (summed) chemical formulas

At this level (summed) atomic compositions are evaluated.
Here, the number of atoms has to be written _before_ the atom. Thus, '2C' means two atoms of carbon.
Empty or invalid entries will be by default returned as mass=0.0, a message will comment such issues. 
 
The mass of an electron can be assigned using 'e'.
```{r ChemFormMolMass1, echo=TRUE}
massDeFormula(c("12H12O", "HO", " 2H 1 Se, 6C 2N", "HSeCN", " ", "e"))
# Note, that empty/invalid entries will be returned as a mass of 0.0 .

# Ignore empty/invalid entries
massDeFormula(c("12H12O", "HO", " 2H 1 Se, 6C 2N", "HSeCN"), rmEmpty=TRUE)

```

Using the argument _massTy_ one can switch this and similar functions from this package from default monoisotopic mass to average mass mode :
```{r ChemFormMolMass2, echo=TRUE}
massDeFormula(c("12H12O", "HO", " 2H 1 Se, 6C 2N", "HSeCN"), massTy="aver")

```

### Molecular masses based on amino-acid sequence
The mass of these amino-acids can be used:
```{r AAseqMolMass, echo=TRUE}
AAmass()
```

Here the one-letter amino-acid code is used to descibre peptides or proteins.
```{r AAseqMolMass2, echo=TRUE}
## mass of peptide (or protein)
pep1 <- c(aa="AAAA",de="DEFDEF")
convAASeq2mass(pep1, seqN=FALSE)
```


## Reading Fasta Files (from Uniprot)
This package contains a parser for Fasta-files allowing to separate different fields of meta-data like IDs, Name and Species.
Here we will read a tiny example fasta-file obtained from a collection of typical contaminants in proteomics.

```{r readFasta, echo=TRUE}
path1 <- system.file('extdata', package='wrProteo')
fiNa <-  "conta1.fasta"
## basic reading of Fasta
fasta1 <- readFasta2(file.path(path1,fiNa))
str(fasta1)

## now let's read and further separate details in annotation-fields
fasta1det <- readFasta2(file.path(path1,fiNa), tableOut=TRUE)
str(fasta1det)
```

## Annotation

In most 'Omics' acitivities getting additional annotation may get a bit tricky.
In Proteomics most mass-spectrometry software will use the informaton provided in the Fasta-file as annotation (as provided from UniProt).
But this lacks for example chromosomal location information.
There are are many repositories with genome-, gene- and protein-annotation and most of them are linked, but sometimes the links get broken when 
data-base updates are not done everywhere or are not followed by new re-matching. The Fasta-files used initially for mass-spectrometry peak-identification
may be (slightly) not up to date (sometimes gene-or protein IDs do change or may even disappear) and thus will contribute to a certain percentage of entries hard to link.

In the context of adding chromosomal annotation to a list of proteins here the following concept is developed :
Annotation-tables from [UCSC](https://genome.ucsc.edu/cgi-bin/hgTables) are available for a good number of species and can be downloaded for conventient off-line search. Howwever, in the context of less common species we realized that the UniProt tables from UCSC had many times low yield in final matching.
For this reason we propose the slightly more complicated route that provided finally a much higher success-rate to find chromosomal locations for a list of UniProt IDs. First one needs to download from [UCSC](https://genome.ucsc.edu/cgi-bin/hgTables) the table corresponding to the species of question fields _'clade','genome','assembly'_). For _'group'_ choose 'Genes and Gene Predictions' and for _'track'_ choose 'Ensembl Genes', as table choose 'ensGene'. 
In addition, it is possible to select either the entire genome-annotation or user-specified regions. 
In terms of 'output-format' one may choose 'GTF' (slightly more condensed, no headers) or 'all filds from selected table'.

The strategy presented here :

Locate & download organism annotation from UCSC, read into R (_readUCSCtable()_) ->  from R export (non-redundant) 'enst'-IDs (still _readUCSCtable()_ ), 
get corresponding UniProt-IDs at UniProt site, save as file and import result into R (_readUniProtExport()_ ) -> (in R) combine with initial UCSC table (_readUniProtExport()_ )

The function _readUCSCtable()_ is able to read such files downloaded from UCSC, compressed .gz files can be read, too. 
In the example below we'll just look at chromosome 11 of the human genome - to keep files small.

```{r readUCSC1, echo=TRUE}
path1 <- system.file("extdata", package="wrProteo")
gtfFi <- file.path(path1, "UCSC_hg38_chr11extr.gtf")
UcscAnnot1 <- readUCSCtable(gtfFi)

# The Ensemble transcript identifyers and their chromosomal locations :
head(UcscAnnot1)
```

However, this annotation does not provide protein IDs. In order to obtain the corresponding protein IDs an additional step is required : Here we will use the batch seach/conversion tool from [UniProt](https://www.uniprot.org/uploadlists/). In order to do so, we can export directly from _readUCSCtable()_ a small text-file which can the be fed into the UniProt batch-search tool.

```{r readUCSC2, echo=TRUE}
# Here we'll redo reading the UCSC table, plus immediatley write the file for UniProt conversion 
#  (in this vignette we write to tempdir() to keep things tidy)
expFi <- file.path(tempdir(),"deUcscForUniProt2.txt")
UcscAnnot1 <- readUCSCtable(gtfFi, exportFileNa=expFi)
```

Now everything is ready to go to [UniProt](https://www.uniprot.org/uploadlists/) for retreiving the corresponding UniProt-IDs. 
Since we exported Ensemble transcript IDs (ENSTxxx), select converting from 'Ensembl Transcript' to 'UniProtKB'. 
Then, when downloading the conversion results, choose tab-separated file format (compression is recommended), this may take several seconds (depening on the size).

It is suggested to rename the downloaded file so one can easily understand it's content.
Note, that the function _readUniProtExport()_ can also read .gz compressed files. 
To continue this vignette we'll use a result which has been downloaded from [UniProt](https://www.uniprot.org/uploadlists/) and renamed to 'deUniProt_hg38chr11extr.tab'.
One may also optionally define a specific genomic region of interest using the argument 'targRegion', here the entire chromosome 11 was chosen.

```{r readUniProt1, echo=TRUE}
deUniProtFi <- file.path(path1, "deUniProt_hg38chr11extr.tab")
deUniPr1 <- readUniProtExport(UniP=deUniProtFi, deUcsc=UcscAnnot1, targRegion="chr11:1-135,086,622")
str(deUniPr1)
```

The resulting data.frame (ie the column 'UniProtID') may be used to complement protein annotation after importing mass-spectrometry peak- and protein-identification results.
Obviously, using recent Fasta-files from UniProt for protein-identification will typically give better matching at the end.

You may note that sometimes Ensemble transcript IDs are written as 'enst00000410108' wheras at other places it may be written as 'ENST00000410108.5'.
The function _readUniProtExport()_ switches to a more flexible search mode stripping of version-numbers and reading all as lower-caps, if initial direct matching reveils less than 4 hits.

Finally, it should be added, that of course other ways of retreiving annotation exist, in particular using the annotation-packages provided by [Bioconductor](https://www.bioconductor.org/).
 

## Importing and Treating Data From Quantitative Proteomics

This package provides support for importing quantitation results from [Proteome Discoverer](https://www.thermofisher.com/order/catalog/product/OPTON-30812),
 [MaxQuant](https://www.maxquant.org) and [Proline](http://www.profiproteomics.fr/proline/). All quantitation import functions offer special features for separating species
 for optional different treatment. 
Normalization aims to eliminate/reduce variablity introduced to the data not linked to the original biological question.
Of course, a well designed experiment with sufficent replicates is crucial for performing efficient normalization.  
Technical replicates are very frequently found in proteomics, they allow to asses the influence of repeated injection of the same material.
Biological replicates allow interpreting experiments in a more general way. 
Multiple options for normalization are available in the package [wrMisc](https://CRAN.R-project.org/package=wrMisc) and can be called when importing data.
Global median or global mean normalization have proved to provide robust results in numerous settings. However, they depend on the hypothesis that there are no global changes.
This implies that the number of proteins changing abundance in a strong way should be small.

Typical contaminants in proteomics like keratins are very abudant and thus may influence global mean normalization. 
The import functions from this package let's the user to choose if all proteins or a subset should be considered when determining normalization factors.
For example, you may want to exclude contaminants from normalization since their dyamics may reflect other cofactors than the biological question.
In the case of benchmark-tests it is very common to different species, like the human spike-in set [UPS-1](https://www.sigmaaldrich.com/life-science/proteomics/mass-spectrometry/ups1-and-ups2-proteomic.html).  
In such cases you may orient normalization on a primary species to avoid having high concentrations of 
spike-in standards influencing the normalization.

All import functions generate lists separating (selected) annotation data (annot) from normalized log2-quantitation data (quant)
and initial quantitation (raw).


 
### Read data from Proteome Discoverer

[Proteome Discoverer](https://www.thermofisher.com/order/catalog/product/OPTON-30812) is commercial software from [ThermoFisher](https://www.thermofisher.com/de/de/home.html).
In [Proteome Discoverer](https://www.thermofisher.com/order/catalog/product/OPTON-30812) quantitation data on level of consensus-proteins should be exported to tabulated text files, which can be treated by this function.
Note, for this vignette we have only extracted a few hundred lines to make the data-set easier to manipulate.

```{r readProteomeDiscoverer, echo=TRUE}
path1 <- system.file("extdata", package="wrProteo")
fiNaPd <- "exampleProtDiscov1.txt"
dataPD <- readPDExport(file=fiNaPd, path=path1, normalizeMeth="median")
## a summary of the quantitation data
summary(dataPD$quant)
```
 
### Read data from MaxQuant

[MaxQuant](https://www.maxquant.org) is free software provided by the [Max-Planck-Insutute](https://www.biochem.mpg.de/de), 
see [Tyanova et al 2016](https://www.nature.com/articles/nprot.2016.136) (doi: 10.1093/bioinformatics/btaa118). 
Typically [MaxQuant](https://www.maxquant.org) exports by default quantitation data on level of consensus-proteins as a folder called txt with a file called proteinGroups.txt .
So in a standard case one needs only to provide the path to this file. However, for this vignette we have only extracted a few hundred lines to make
the data-set easier to manipulate, and thus it has gotten a different name.



```{r readMaxQuant, echo=TRUE}
path1 <- system.file("extdata", package="wrProteo")
fiNaMa <- "proteinGroupsMaxQuantUps1.txt"
specPref1 <- c(conta="conta|CON_|LYSC_CHICK", mainSpecies="YEAST", spike="HUMAN_UPS")
dataMQ <- readMaxQuantFile(path1, file=fiNaMa, specPref=specPref1, normalizeMeth="median")
## a summary of the quantitation data
summary(dataMQ$quant)
```

### Read data from Proline

[Proline](http://www.profiproteomics.fr/proline/) is free software provided by the Profi-consortium, 
see [Bouyssié et al 2020](https://academic.oup.com/bioinformatics/article/36/10/3148/5756203) (doi: 10.1038/nprot.2016.136).
In [Proline](http://www.profiproteomics.fr/proline/) quantitation data on level of consensus-proteins can be exported to csv or tabulated text files, which can be treated by this function.
Note, for this vignette we have only extracted a few hundred lines to make the data-set easier to manipulate.

```{r readProline, echo=TRUE}
normalizeMeth <- NULL
path1 <- system.file("extdata", package="wrProteo")
fiNaPl <- "exampleProlineABC.csv"
dataPL <- readProlineFile(file.path(path1,fiNaPl) )
## a summary of the quantitation data
summary(dataPL$quant)
```


## Normalization

As mentioned, the aim of normalization is to remove bias in data not linked to the original (biological) question.
The import functions presented above do already by default global median normalization.
In overal it is important to inspect results from normalization, graphical display of histograms, boxplots or violin-plots usually work well to compare distributions.
Multiple options exist for normalizing data, for example the function normalizeThis from the package [wrMisc](https://CRAN.R-project.org/package=wrMisc) can be used to run additional normalization.

Different normalization procedures intervene with different 'aggressiveness', ie capacity of deformining the initial data. 
In general we suggest to start normalizing using 'milder' procedures, like global median and switch to more intervening methods if initial results seem not satisfactory.
Beware, heavy normalization procedures may also alter the main information you want to analyze. 
Ie, some biologically true positive changes may start to fade or dissapear when inappropriate normalization gets performed. 
Please note, that normalization should be performed before NA-inputation to avoid introducing new bias in the group of imputed values.


## Imputation of NA-values

In Proteomics the quantitation of very low abundances is very challenging and typically absent or very low abundances appear in the results as 0 or NA.
Typically this may be liked to the fact that no peak is detected in a MS-1 chromatogram (for a given LC elution-time) where other samples had a strong peak 
with succesful MS-2 identification. Data teated with MaxQuant have typically a higher degree of NA values.
To simplify the treatment all 0 values are transformed to NA, anyway they would not allow log2 transformation either.

Before replacing NA-values it is important to verify that such values may be associated to absent or very low abundances. 
To do so, we suggest to inspect groups of replicate-measurments. In particular with multiple technical replicates of the same sample 
it is supposed that any variability observed is not linked to the sample itself. So for each NA that occurs in the data we suggest to 
look what was reported for the same protein with the other (technical) replicates. 
This brings us to the term of 'NA-neighbours' (quantifications for the same protein in replicates).
When drawing histograms of NA-neighbours one can visually inspect and verify that NA-neighbours are typically low abundance values, 
however, but not necessarily the lowest values observed in the entire data-set.

This package proposes two related strategies for NA-imputation.
First, the classical imputation of NA-values using Normal distributed random data is presented.
Then, a more elaborate version based on repeated implementations to obtain more robust results is presented.

```{r NA_ProteomeDiscoverer, echo=TRUE}
## Let's inspect NA values as graphic
matrixNAinspect(dataPD$quant, gr=gl(2,3), tit="Tiny example data from ProteomeDiscoverer") 
```

```{r NA_MaxQuant, echo=TRUE}
## Let's inspect NA values as graphic
matrixNAinspect(dataMQ$quant, gr=gl(3,3), tit="Tiny example data from MaxQuant") 
```

```{r NA_Proline, echo=TRUE}
## Let's inspect NA values as graphic
matrixNAinspect(dataPL$quant, gr=as.factor(substr(colnames(dataPL$quant),1,1)),
  tit="Tiny example data from Proline") 
```

So only if the hypothesis of NA-neighbours as typically low abundance values gets confirmed by visual inspection of the histograms, 
one may proceed to replacing them by low random values. If one uses a unique (very) low value for NA-replacements, this
will easily pose a problem when t-tests should be employed to look for proteins changing abundance between two or more groups of samples.
Therefore it is common practice to draw random values from a Normal distribution representing this lower end of abundance values.
Nevertheless, the choice of the parameters of this Normal distribution is very delicate. 

The functions proposed here offer automatic selection of these parameters, which have been tested in a number of different projects.
However, this choice should be checked by critically inpecting the histograms of 'NA-neighbours' (ie successful quantitations in other 
replicate samples of the same protein) and the final resulting distribution. Initially all NA-neighbours are extracted. 
It is also worth mentioning that in the majority of  data-sets we encountered, such NA-neighbours form skewed distributions. 
Occasionally one may also find instances where 2 out of 3 (or more replicates) are NA.
The successful quantitations of such instances with 2 NA-values per group are considered even more representative, but of course much less observed values remain.
Thus a primary choice is made: If the selection of (min) 2 NA-values per group has more than 300 values, this distribution will be used as base to model 
the distribution for drawing random values. In this case, by default the 0.18 quantile of the 2 NA-neighbour distribution will be used as mean for 
the new Normal distribution used for NA-replacements. If the number of 2 NA-neighbours is >= 300, (by default) the 0.1 quantile all NA-neighbour values will used. 
Of course, the user has also the possibility to use custom choices for these parameters.

The final replacement is done on all NA values. This also includes proteins with are all NA in a given condition as well a instances of mixed successful qunatitation and NA values.

```{r NArepl_ProteomeDiscoverer, echo=TRUE}
## ProteomeDiscoverer
dataPD$NArepl <- matrixNAneighbourImpute(dataPD$quant,gr=gl(2,3),
  tit="Tiny example from ProteomeDiscoverer") 
```

```{r NArepl_MaxQuant, echo=TRUE}
## MaxQuant
dataMQ$NArepl <- matrixNAneighbourImpute(dataMQ$quant,gr=gl(3,3),tit="Tiny example from MaxQuant") 
```

```{r NArepl_Proline, echo=TRUE}
## Proline
dataPL$NArepl <- matrixNAneighbourImpute(dataPL$quant,gr=gl(3,4),tit="Tiny example from Proline") 
```

However, imputing using normal distributed random data also brings the risk of occasional extreme values.
In the extreme case it may happen that a given protein is all NA in one group, and by chance the random values turn out be rather high.
Then the final group mean of imputed values may be even higher than the mean of another group with successfull quantitations.
Of course in this case it would be a bad interpretation to consider the protein in question upregulated in the sample where initially all values were NA.
To circumvent this problem there are 2 options : Firstly, one may use special filtering schemes to exclude such constellations from final results or secondly,
one could repeat replacement of NA-values numerous times.

This type of filtering can be performed using presenceFilt (package [wrMisc](https://CRAN.R-project.org/package=wrMisc)).

The function _testRobustToNAimputation()_ allows also such repeated replacement of NA-values. See also the following section.


## Statistical Testing

Statistical test ing in the context of proteomics data poses challanges similar to transcriptomics : 
Many times the number of replicate-samples is fairly low and the inter-measurement variability quite high.
In some unfortunate cases proteins with rather constant quantities may appear as false positives when searching for proteins who's abundance changes between two groups of samples : If the apparent variability is by chance too low, the respective standard-deviations will be low and a plain t-test may give very enthousiastic p-values.  
Next to stringent filtering (previous section of this vignette) the shrinkage when estimating the intra-group/replicate variance from the Bioconductor package [limma](https://bioconductor.org/packages/release/bioc/html/limma.html) turns out very helpful, 
see [Ritchie et al 2015](https://academic.oup.com/nar/article/43/7/e47/2414268) (doi: 10.1093/nar/gkv007). 
In this package the function _eBayes()_ has been used an it's use adopted to proteomics.

The function _testRobustToNAimputation()_ performs NA-imputation and statistical testing (after repeated imputation) between all groups of samples the same time (as it would be inefficient to separate these two tasks). The tests underneith apply shrinkage from the empirical Bayes procedure from the bioconductor package [limma](https://bioconductor.org/packages/release/bioc/html/limma.html).  In addition, various formats of multiple test correction can be directly added to the results : Benjamini-Hochberg FDR, local false discovery rate (lfdr, using the package [fdrtool](https://CRAN.R-project.org/package=fdrtool), see [Strimmer 2008](https://academic.oup.com/bioinformatics/article/24/12/1461/196272) doi: 10.1093/bioinformatics/btn209), or modified testing by [ROTS](https://bioconductor.org/packages/release/bioc/html/ROTS.html), etc ...

The fact that a single round of NA-imputation may provoque false positives as well as false negatives, made it necessary to combine this (iterative) process of NA-imputation and subsequent testing in one single function. 


```{r testRobustToNAimputation_PL1, echo=TRUE}
## Impute NA-values repeatedly and run statistical testing after each round of imputations
testPL <- testRobustToNAimputation(dataPL$quant, gr=gl(3,4), lfdrInclude=FALSE) 
## Note, this example is too small for reliable lfdr estimation (would give warning)

## test results: classical BH FDR
head(testPL$BH)
sum(testPL$BH[,1] < 0.05, na.rm=TRUE)

## the data after repeated NA-imputation
head(testPL$datImp)

```

## Acknowledgements
The author wants to acknowledge the support by the [IGBMC](http://www.igbmc.fr/) (CNRS UMR 7104, Inserm U 1258), [CNRS](http://www.cnrs.fr/), [IGBMC](http://www.igbmc.fr/), [Université de Strasbourg](https://www.unistra.fr) and [Inserm](https://www.inserm.fr/).
My collegues from the [proteomics platform](http://proteomics.igbmc.fr/) at the IGBMC work very commited to provide high quality mass-spectrometry data (including some of those used here).
Furthermore, many very fruitful discussions with colleages on national and international level have helped to improve and disseminate the tools presented here.



## Session-Info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
