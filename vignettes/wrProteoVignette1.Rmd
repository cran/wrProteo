---
title: "Getting started with wrProteo"
author: Wolfgang Raffelsberger
date: '`r Sys.Date()`'
output:
  knitr:::html_vignette:
    toc: true
    fig_caption: yes
  pdf_document:
    highlight: null
    number_sections: no
vignette: >
  %\VignetteIndexEntry{wrProteoVignette1}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction
This package contains a collection of various tools in Proteomics. 
To get started, we need to load the package "[wrMisc](https://CRAN.R-project.org/package=wrMisc)" and 
this package([wrProteo](https://CRAN.R-project.org/package=wrProteo)), both are available from CRAN.

```{r, include = FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment = "#>")
```


```{r setup, echo=FALSE, messages=FALSE, warnings=FALSE}
suppressPackageStartupMessages({
    library(wrMisc)
    library(wrProteo)
})
```



## Calculating molecular masses from composition formulas

### Molecular masses based on (summed) chemical formulas 
```{r ChemFormMolMass, echo=TRUE}
massDeFormula(c("12H12O","HO"," 2H 1 Se, 6C 2N","HSeCN"," ","e"))
```

### Molecular masses based on amino-acid sequence
```{r AAseqMolMass, echo=TRUE}
AAmass()
```
```{r AAseqMolMass2, echo=TRUE}
## mass of peptide (or protein)
pep1 <- c(aa="AAAA",de="DEFDEF")
convAASeq2mass(pep1,seqN=FALSE)
```


### Reading Fasta files (from Uniprot)
This package contains a parser for Fasta-files allowing to separate different fields of meta-data like IDs, Name and Species.
Here we will read a tiny example fasta-file obtained from a collection of typical contaminants in proteomics.
```{r readFasta, echo=TRUE}
path1 <- system.file('extdata',package='wrProteo')
fiNa <-  "conta1.fasta"
## basic reading of Fasta
fasta1 <- readFasta2(file.path(path1,fiNa))
str(fasta1)

## now let's read and further separate annotation-fields
fasta2 <- readFasta2(file.path(path1,fiNa),tableOut=TRUE)
str(fasta2)
```



## Importing and treating data from quantitative proteomics

This package provides support for importing quantitation results from [Proteome Discoverer](https://www.thermofisher.com/order/catalog/product/OPTON-30812),
 [MaxQuant](https://www.maxquant.org) and [Proline](http://proline.profiproteomics.fr/). All quantitation import functions offer special features for separating species
 for optional different treatment. 
Normalization aims to eliminate/reduce variablity introduced to the data not linked to the original biological question.
Of course, a well designed experiment with sufficent replicates is crucial for performing efficient normalization.  
Technical replicates are very frequently found in proteomics, they allow to asses the influence of repeated injection of the same material.
Biological replicates allow interpreting experiments in a more general way. 
Multiple options for normalization are available in the package [wrMisc](https://CRAN.R-project.org/package=wrMisc) and can be called when importing data.
Global median or global mean normalization have proved to provide robust results in numerous settings. However, they depend on the hypothesis that there are no global changes.
This implies that the number of proteins changing abundance in a strong way should be small.

Typical contaminants in proteomics like keratins are very abudant and thus may influence global mean normalization. 
The import functions from this package let's the user to choose if all proteins or a subset should be considered when determining normalization factors.
For example, you may want to exclude contaminants from normalization since their dyamics may reflect other cofactors than the biological question.
In the case of benchmark-tests it is very common to different species, like the human spike-in set [UPS-1](https://www.sigmaaldrich.com/life-science/proteomics/mass-spectrometry/ups1-and-ups2-proteomic.html).  
In such cases you may orient normalization on a primary species to avoid having high concentrations of 
spike-in standards influencing the normalization.

All import functions generate lists separating (selected) annotation data (annot) from normalized log2-quantitation data (quant)
and initial quantitation (raw).


 
### Read data from Proteome Discoverer
In [Proteome Discoverer](https://www.thermofisher.com/order/catalog/product/OPTON-30812) quantitation data on level of consensus-proteins should be exported to tabulated text files, which can be treated by this function.
Note, for this vignette we have only extracted a few hundred lines to make the data-set easier to manipulate.
```{r readProteomeDiscoverer, echo=TRUE}
path1 <- system.file("extdata",package="wrProteo")
fiNa <- "exampleProtDiscov1.txt"
dataPD <- readPDExport(file=fiNa,path=path1)
## a summary of the quantitation data
summary(dataPD$quant)
```
 
### Read data from MaxQuant
Typically [MaxQuant](https://www.maxquant.org) exports by default quantitation data on level of consensus-proteins as a folder called txt with a file called proteinGroups.txt .
So in a standard case one needs only to provide the path to this file. However, for this vignette we have only extracted a few hundred lines to make
the data-set easier to manipulate, and thus it has gotten a different name.


```{r readMaxQuant, echo=TRUE}
fiNa <- "proteinGroupsMaxQuantUps1.txt"
specPref1=c(conta="conta|CON_|LYSC_CHICK",mainSpecies="YEAST",spike="HUMAN_UPS")
dataMQ <- readMaxQuantFile(path1,file=fiNa,specPref=specPref1)
## a summary of the quantitation data
summary(dataMQ$quant)
```

### Read data from Proline
In [Proline](http://proline.profiproteomics.fr/) quantitation data on level of consensus-proteins can be exported to csv or tabulated text files, which can be treated by this function.
Note, for this vignette we have only extracted a few hundred lines to make the data-set easier to manipulate.

```{r readProline, echo=TRUE}
path1 <- system.file("extdata",package="wrProteo")
fiNa <- "exampleProlineABC.csv"
dataPL <- readProlineFile(file.path(path1,fiNa))
## a summary of the quantitation data
summary(dataPL$quant)
```


## Normalization

As mentioned, the aim of normalization is to remove bias in data not linked to the original (biological) question.
The import functions presented above do already by default global median normalization.
In overal it is important to inspect results from normalization, graphical display of histograms, boxplots or violin-plots usually work well to compare distributions.
Multiple options exist for normalizing data, for example the function normalizeThis from the package wrMisc can be used to run additional normalization.

Different normalization procedures intervene with different 'aggressiveness', ie capacity of deformining the initial data. 
In general we suggest to start normalizing using 'milder' procedures, like global median and switch to more intervening methods if initial results seem not satisfactory.
Beware, heavy normalization procedures may also alter the main information you want to analyze. 
Ie, some biologically true positive changes may start to fade or dissapear when inappropriate normalization gets performed. 
Please note, that normalization should be performed before NA-inputation to avoid introducing new bias in the group of imputed values.


## Imputation of NA-values
In Proteomics the quantitation of very low abundances is very challenging and typically absent or very low abundances appear in the results as 0 or NA.
Typically this may be liked to the fact that no peak is detected in a MS-1 chromatogram (for a given LC elution-time) where other samples had a strong peak 
with succesful MS-2 identification. Data teated with MaxQuant have typically a higher degree of NA values.
To simplify the treatment all 0 values are transformed to NA, anyway they would not allow log2 transformation either.

Before replacing NA-values it is important to verify that such values may be associated to absent or very low abundances. 
To do so, we suggest to inspect groups of replicate-measurments. In particular with multiple technical replicates of the same sample 
it is supposed that any variability observed is not linked to the sample itself. So for each NA that occurs in the data we suggest to 
look what was reported for the same protein with the other (technical) replicates. 
This brings us to the term of 'NA-neighbours' (quantifications for the same protein in replicates).
When drawing histograms of NA-neighbours one can visually inspect and verify that NA-neighbours are typically low abundance values, 
however, but not necessarily the lowest values observed in the entire data-set.

This package proposes two related strategies for NA-imputation.
First, the classical imputation of NA-values using Normal distributed random data is presented.
Then, a more elaborate version based on repeated implementations to obtain more robust results is presented.

```{r NA_ProteomeDiscoverer, echo=TRUE}
## Let's inspect NA values as graphic
matrixNAinspect(dataPD$quant,gr=gl(2,3),tit="Tiny example data from ProteomeDiscoverer") 
```

```{r NA_MaxQuant, echo=TRUE}
## Let's inspect NA values as graphic
matrixNAinspect(dataMQ$quant,gr=gl(3,3),tit="Tiny example data from MaxQuant") 
```

```{r NA_Proline, echo=TRUE}
## Let's inspect NA values as graphic
matrixNAinspect(dataPL$quant,gr=as.factor(substr(colnames(dataPL$quant),1,1)),
  tit="Tiny example data from Proline") 
```

So only if the hypothesis of NA-neighbours as typically low abundance values gets confirmed by visual inspection of the histograms, 
one may proceed to replacing them by low random values. If one uses a unique (very) low value for NA-replacements, this
will easily pose a problem when t-tests should be employed to look for proteins changing abundance between two or more groups of samples.
Therefore it is common practice to draw random values from a Normal distribution representing this lower end of abundance values.
Nevertheless, the choice of the parameters of this Normal distribution is very delicate. 

The functions proposed here offer automatic selection of these parameters, which have been tested in a number of different projects.
However, this choice should be checked by critically inpecting the histograms of 'NA-neighbours' (ie successful quantitations in other 
replicate samples of the same protein) and the final resulting distribution. Initially all NA-neighbours are extracted. 
It is also worth mentioning that in the majority of  data-sets we encountered, such NA-neighbours form skewed distributions. 
Occasionally one may also find instances where 2 out of 3 (or more replicates) are NA.
The successful quantitations of such instances with 2 NA-values per group are considered even more representative, but of course much less observed values remain.
Thus a primary choice is made: If the selection of (min) 2 NA-values per group has more than 300 values, this distribution will be used as base to model 
the distribution for drawing random values. In this case, by default the 0.18 quantile of the 2 NA-neighbour distribution will be used as mean for 
the new Normal distribution used for NA-replacements. If the number of 2 NA-neighbours is >= 300, (by default) the 0.1 quantile all NA-neighbour values will used. 
Of course, the user has also the possibility to use custom choices for these parameters.

The final replacement is done on all NA values. This also includes proteins with are all NA in a given condition as well a instances of mixed successful qunatitation and NA values.

```{r NArepl_ProteomeDiscoverer, echo=TRUE}
## ProteomeDiscoverer
dataPD$NArepl <- matrixNAneighbourImpute(dataPD$quant,gr=gl(2,3),
  tit="Tiny example from ProteomeDiscoverer") 
```

```{r NArepl_MaxQuant, echo=TRUE}
## MaxQuant
dataMQ$NArepl <- matrixNAneighbourImpute(dataMQ$quant,gr=gl(3,3),tit="Tiny example from MaxQuant") 
```

```{r NArepl_Proline, echo=TRUE}
## Proline
dataPL$NArepl <- matrixNAneighbourImpute(dataPL$quant,gr=gl(3,4),tit="Tiny example from Proline") 
```

However, imputing using normal distributed random data also brings the risk of occasional extreme values.
In the extreme case it may happen that a given protein is all NA in one group, and by chance the random values turn out be rather high.
Then the final group mean of imputed values may be even higher than the mean of another group with successfull quantitations.
Of course in this case it would be a bad interpretation to consider the protein in question upregulated in the sample where initially all values were NA.
To circumvent this problem there are 2 options : Firstly, one may use special filtering schemes to exclude such constellations from final results or secondly,
one could repeat replacement of NA-values numerous times.

This type of filtering can be performed using presenceFilt (package wrMisc).

The function testRobustToNAimputation allows such repeated replacement of NA-values. 
This function performs NA-imputation and statistical testing (after repeated imputation) between all groups of samples the same time (as it would be inefficient to separate these two tasks). The tests underneith apply shrinkage from the empirical Bayes procedure from the bioconductor package [limma](https://bioconductor.org/packages/release/bioc/html/limma.html). 

```{r testRobustToNAimputation_ProteomeDiscoverer, echo=TRUE}
## Impute NA-values repeatedly and run statistical testing after each round of imputations
testPL <- testRobustToNAimputation(dataPL$quant,gr=gl(3,4),lfdrInclude=FALSE) 
## Note, this example is too small for reliable lfdr estimation (would give warning)

## test results: classical BH FDR
head(testPL$BH)
sum(testPL$BH[,1] < 0.05,na.rm=TRUE)
## the data after repeated NA-imputation
head(testPL$datImp)

```






## Session-Info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
