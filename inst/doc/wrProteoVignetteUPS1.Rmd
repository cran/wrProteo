---
title: "Analyzing UPS1 Spike-in Experiments (Example Ramus 2016 Dataset)"
author: Wolfgang Raffelsberger
date: '`r Sys.Date()`'
output:
  knitr:::html_vignette:
    toc: true
    fig_caption: yes
  pdf_document:
    highlight: null
    number_sections: no
vignette: >
  %\VignetteIndexEntry{wrProteoRamus_vignette1}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


## Introduction
This vignete shows how [UPS1](https://www.sigmaaldrich.com/life-science/proteomics/mass-spectrometry/ups1-and-ups2-proteomic.html) spike-in experiments may be analyzed using the packages [wrProteo](https://CRAN.R-project.org/package=wrProteo),
[wrMisc](https://CRAN.R-project.org/package=wrMisc) and [wrGraph](https://CRAN.R-project.org/package=wrGraph), all are available on CRAN. 

Furthermore, the Bioconductor package [limma](https://bioconductor.org/packages/release/bioc/html/limma.html) will be used internally for it's robust statistical testing.

```{r, include = FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment = "#>")
```

```{r install, echo=TRUE, eval=FALSE}
# If not already installed, you'll have to install this package and wrMisc first.
install.packages("wrMisc")
install.packages("wrProteo")

# The package wrGraph is recommended for better graphics
install.packages("wrGraph")

# You cat start the vignettes for this package by typing :
browseVignettes("wrProteo")    #  ... and the select the html output
```

Now let's load the packages needed :

```{r setup, echo=TRUE, messages=FALSE, warnings=FALSE}
library(wrMisc)
library(wrProteo)
library(wrGraph)

# Version number for wrProteo :
packageVersion("wrProteo")
```


### Benchmark Tests Experimental Setup

The main aim of the experimental setup in [UPS1](https://www.sigmaaldrich.com/life-science/proteomics/mass-spectrometry/ups1-and-ups2-proteomic.html) spike-in experiments is to provide a framework to test identification and quantitation procedures in proteomics.
By mixing known amounts of a collection of human proteins (UPS1) in various concentrations into a yeast protein extract, one expects to find only human proteins varying between samples. 
In terms of ROC curves the human proteins are expected to show up as true positives (TP).
In contrast, all yeast proteins were always added in the same quantity and should thus be observed constant, ie as true negatives (TN).


### The Ramus Data-Set

The data were published with the article : [Ramus et al 2016](https://doi.org/10.1016/j.jprot.2015.11.011) Benchmarking quantitative label-free LC-MS data processing workflows using a complex spiked proteomic standard dataset. J Proteomics 2016 Jan 30;132:51-62. PMID: 26585461 doi: 10.1016/j.jprot.2015.11.011

This dataset is available on PRIDE as [PXD001819](https://www.ebi.ac.uk/pride/archive/projects/PXD001819) (and/or on ProteomeXchange).

Briefly, this experiment aims to compare quantification of the heterologous spike-in [UPS1](https://www.sigmaaldrich.com/life-science/proteomics/mass-spectrometry/ups1-and-ups2-proteomic.html) in yeast protein extracts as constant matrix.


### Additional Functions

```{r functions1, echo=TRUE}
## Two small functions we'll need lateron

replSpecType <- function(x, annCol="SpecType", replBy=cbind(old=c("mainSpe","species2"), new=c("Yeast","UPS1"))) {
  ## rename $annot[,"SpecType"] to more specific names
  chCol <- annCol[1] %in% colnames(x$annot)
  if(chCol) { chCol <- which(colnames(x$annot)==annCol[1])
    chIt <- replBy[,1] %in% unique(x$annot[,chCol])    # check items to replace if present
    if(any(chIt)) for(i in which(chIt)) {useLi <- which(x$annot[,chCol] %in% replBy[i,1]); cat("useLi",head(useLi),"\n"); x$annot[useLi,chCol] <- replBy[i,2]}
  } else message(" replSpecType: 'annCol' not found in x$annot !")
  x }
  
replNAProtNames <- function(x,annCol=c("ProteinName","Accession","SpecType")) {
  ## replace in $annot missing ProteinNames by concatenating Accession + SpecType (ie 2nd & 3rd of annCol)
  chCol <- annCol %in% colnames(x$annot)
  if(all(chCol)) {
    chNA <- is.na(x$annot[,annCol[1]])
    if(any(chNA)) x$annot[which(chNA),annCol[1]] <- paste(x$annot[which(chNA),annCol[2]],x$annot[which(chNA),annCol[3]],sep="_")
  } else message(" replNAProtNames: none of the columnnames 'annCol' found in x$annot !")
  x }
```



## Protein Identification and Initial Quantification


### MaxQuant

[MaxQuant](https://www.maxquant.org) is free software provided by the [Max-Planck-Insutute](https://www.biochem.mpg.de/en), 
see [Tyanova et al 2016](https://doi.org/10.1038/nprot.2016.136). 
Typically [MaxQuant](https://www.maxquant.org) exports by default quantitation data on level of consensus-proteins as a folder called txt with a file called *proteinGroups.txt* .
So in a standard case one needs only to provide the path to this file.

```{r readMaxQuant, fig.height=8, fig.width=9.5, fig.align="center", echo=TRUE}
path1 <- system.file("extdata", package="wrProteo")
fiNaMa <- "proteinGroups.txt.gz"
specPrefMQ <- c(conta="CON_|LYSC_CHICK", mainSpecies="OS=Saccharomyces cerevisiae", spike="HUMAN_UPS")

dataMQ <- readMaxQuantFile(path1, file=fiNaMa, specPref=specPrefMQ, refLi="mainSpe")
```

The data were imported and median-normalized, the protein annotation was parsed to atomatically extract IDs, protein-names and species information.

```{r readMaxQuant2, fig.height=8, fig.width=9.5, fig.align="center", echo=TRUE}
## a summary of the quantitation data
dim(dataMQ$quant)
summary(dataMQ$quant[,1:8])       # the first 8 cols
colnames(dataMQ$annot)[1:12]
table(dataMQ$annot[,"Species"])
table(dataMQ$annot[,"SpecType"])
```


### ProteomeDiscoverer

[ProteomeDiscoverer](https://www.thermofisher.com/order/catalog/product/OPTON-30812) is commercial software from ThermoFisher (www.thermofisher.com).
In this case, the identification was performed using the XCalibur module of ProteomeDiscoverer.
In [ProteomeDiscoverer](https://www.thermofisher.com/order/catalog/product/OPTON-30812) quantitation data on level of consensus-proteins should be exported to tabulated text files, which can be treated by this function.
The resultant data were export as 'Proteins' in tablulated format (the option R-headers was checked, however data can also be read when this option was not chosen).

```{r readProteomeDiscoverer1, fig.height=8, fig.width=9.5, fig.align="center", echo=TRUE}
path1 <- system.file("extdata", package="wrProteo")
fiNaPd <- "pxd001819_PD2.4_Proteins.txt.gz"
 file.exists(file.path(path1,fiNaPd))
## Note: data exported from ProteomeDiscoverer does not have proper column-names 
sampNa <- paste(rep(c(50,125,250,500,2500,5000,12500,25000,50000), each=3),"amol_R",rep(1:3,9),sep="") 
specPrefPD <- c(conta="Bos tauris|Gallus", mainSpecies="OS=Saccharomyces cerevisiae", spike="OS=Homo sapiens")

dataPD <- readPDExport(file=fiNaPd, path=path1, sampleNames=sampNa, refLi="mainSpe", specPref=specPrefPD)
```


The data were imported and median-normalized, the protein annotation was parsed to atomatically extract IDs, protein-names and species information.

```{r readProteomeDiscoverer2, fig.height=8, fig.width=9.5, fig.align="center", echo=TRUE}
## a summary of the quantitation data
summary(dataPD$quant[,1:8])        # the first 8 cols
dim(dataPD$quant)
colnames(dataPD$annot)[]
#head(dataPD$annot)
table(dataPD$annot[,"Species"])
table(dataPD$annot[,"SpecType"])
```


```{r ProteomeDiscoverer2, echo=FALSE}
# get ProteomeDiscoverer2 in same order
```

### Proline

[Proline](http://www.profiproteomics.fr/proline/) is free software provided by the [Profi-consortium](http://www.profiproteomics.fr/),         
see [Ramus et al 2016](https://doi.org/10.1016/j.jprot.2015.11.011) and [BouyssiÃ© et al 2020](https://doi.org/10.1093/bioinformatics/btaa118) (Proline: an efficient and user-friendly software suite for large-scale proteomics. Bioinformatics. 2020, PMID: 32096818, DOI: 10.1093/bioinformatics/btaa118 )

In [Proline](http://www.profiproteomics.fr/proline/) quantitation data on level of consensus-proteins can be exported to csv or tabulated text files, which can be treated by this function.


```{r readProline, echo=FALSE}
## shifted for not printing
path1 <- system.file("extdata", package="wrProteo")
#fiNaPl <- "xxProlineABC.csv"
#dataPL <- readProlineFile(file.path(path1,fiNaPl))
## a summary of the quantitation data
#summary(dataPL$quant)
```

### Uniform Re-Arranging of Data

In order for easy and proper comparisons we need to make sure all columns are in the same order.

```{r rearrange1, echo=TRUE}
# get all results (MaxQuant,ProteomeDiscoverer, ...) in same order
sampNa <- paste0(rep(c(50,125,250,500,2500,5000,12500,25000,50000),each=3),"amol_R",rep(1:3,9))
grp9 <- paste0(rep(c(50,125,250,500,2500,5000,12500,25000,50000),each=3),"amol") 

## it is more convenient to re-order columns this way in each project
dataPD <- corColumnOrder(dataPD,sampNames=sampNa)          # already in good order
dataMQ <- corColumnOrder(dataMQ,sampNames=sampNa) 
#dataPL <- corColumnOrder(dataPL,sampNames=sampNa) 
```

The from the protein annotation the membership to 3 groups was extracted : yeast (matrix) as "'main Spe'", UPS1 (spike) as 'species2' and other contaminants ('conta').
The first two terms will be replace by more specific ones ('Yeast' and 'UPS1') :

```{r postTreatm1, echo=FALSE}
## The automatic separation by custom (species) search terms filled in just generic category-names
table(dataPD$annot[,"SpecType"])

## Need to rename $annot[,"SpecType"]  
    dataPDx <- dataPD   # backup
    dataMQx <- dataMQ   # backup
dataPD <- replSpecType(dataPD, replBy=cbind(old=c("mainSpe","species2"), new=c("Yeast","UPS1")))
dataMQ <- replSpecType(dataMQ, replBy=cbind(old=c("mainSpe","species2"), new=c("Yeast","UPS1")))

## Need to addres missing ProteinNames (UPS1) due to missing tags in Fasta
dataPD <- replNAProtNames(dataPD) 
dataMQ <- replNAProtNames(dataMQ) 
```


## Data Treatment


### Normalization
No additional normalization is needed, all data were already median normalized to the host proteins (ie Saccaromyces cerevisiae) after importing the 
initial quantification-output using 'readMaxQuantFile()', and 'readPDExport()'.



### Presence of NA-values

As mentioned in the (general) vignette 'wrProteoVignette1' it is important to investigate the nature of NA-values, in particular the hypothesis that NA-values originate from very low abundance instances (eg non of its peptides identified during the MS1 run).


```{r NA_ProteomeDiscoverer, echo=TRUE}
## Let's inspect NA values as graphic
matrixNAinspect(dataPD$quant, gr=grp9, tit="ProteomeDiscoverer")  # gl(9,3)
```

```{r NA_MaxQuant, echo=TRUE}
## Let's inspect NA values as graphic
matrixNAinspect(dataMQ$quant, gr=gl(9,3), tit="MaxQuant") 
## why only 24 columns => reprocess ?
```

```{r NA_Proline, echo=FALSE}
## shifted for not printing
## Let's inspect NA values as graphic
statusPL <- NULL
#matrixNAinspect(dataPL$quant, gr=as.factor(substr(colnames(dataPL$quant),1,1)), tit="Tiny example data from Proline") 
```


### NA-Imputation and Statistical Testing for Changes in Abundance

NAs values represent a challange for statistical testing. In the sections above we provided evidence that NA-values typically represent proteins with very low protein abundance that finally ended as non-detectable (NA).
The number of NAs varies between samples : Very low concentrations of UPS1 tend not to get detected and thus contribute largely to the NAs. 
Since the amout if yeast proteins stays constant they should always get detected the way in all samples.

```{r nNA1, echo=TRUE} 
## Let's look at the number of NAs. Is there an accumulated number in lower UPS1 semples ?
sumNAperGroup(dataPD$raw, grp9) 
sumNAperGroup(dataMQ$raw, grp9) 

```

The function _testRobustToNAimputation()_ from the pckage wrProteo performs NA-imputation and statistical testing (after repeated imputation) between all groups of samples the same time (as it would be inefficient to separate these two tasks). The tests underneith apply shrinkage from the empirical Bayes procedure from the bioconductor package [limma](https://bioconductor.org/packages/release/bioc/html/limma.html).  In addition, various formats of multiple test correction can be directly added to the results : Benjamini-Hochberg FDR, local false discovery rate (lfdr, using the package [fdrtool](https://CRAN.R-project.org/package=fdrtool), see [Strimmer 2008](https://academic.oup.com/bioinformatics/article/24/12/1461/196272) doi: 10.1093/bioinformatics/btn209), or modified testing by [ROTS](https://bioconductor.org/packages/release/bioc/html/ROTS.html), etc ...
One of the advantages of this method, is that multiple rounds of imputation are run, so that final results (including pair-wise testing) gets stabilized to (rare) stochastic effects without bias due to low variances.

We are ready to launch the testing :
```{r testProteomeDiscoverer, echo=TRUE} 
## Let's run pairwise-testing for ProteomeDiscoverer
testPD <- testRobustToNAimputation(dataPD$quant, gr=grp9, lfdrInclude=TRUE, annot=dataPD$annot)       # gl(9,3
```

```{r testMaxQuant, echo=TRUE}
## Let's run pairwise-testing for MaxQuant
testMQ <- testRobustToNAimputation(dataMQ$quant, gr=grp9, lfdrInclude=TRUE, annot=dataMQ$annot) 
```


```{r testProline, echo=FALSE}
## shifted for not printing
## Let's run pairwise-testing for Proline
statusPL <- NULL
#testPL <- testRobustToNAimputation(dataPL$quant, gr=gl(3,4), lfdrInclude=FALSE, annot=dataPL$annot) 
```
From these results we'll use i) the NA-imputed version of our datasets for plotting principal components and ii) the (stabilized) testing results for counting TP, FP, etc.


To have the statistical testing results in our main object, we'll copy the imputed data to our initial list :
```{r testReorganize, echo=TRUE}
## recuperate imputeded data to main data-object
dataPD$datImp <- testPD$datImp
dataMQ$datImp <- testMQ$datImp
```


## Similarity by PCA

Principal component analysis (PCA) cannot handle NA-values. Either all lines with any NAs have to be excluded, or data after NA-imputation have to be used.
Here, we chose the second option. Plots will be made using the package [wrGraph](https://CRAN.R-project.org/package=wrGraph).

```{r PCA1, fig.height=12, fig.width=9.5, fig.align="center", echo=TRUE}
plotPCAw(testPD$datImp, sampleGrp=grp9, tit="PCA on ProteomeDiscoverer (NAs imputed)", rowTyName="proteins", useSymb2=0)
plotPCAw(testMQ$datImp ,sampleGrp=grp9, tit="PCA on MaxQuant (NAs imputed)", rowTyName="proteins", useSymb2=1:9)
```

Again, since the sample consists predominantly of yeast proteins that are kept constant, one would not expect many sample-related characteristics.
In this case we might be rather interested in the (global) characteristics and similarity of the [UPS1 proteins](https://www.sigmaaldrich.com/life-science/proteomics/mass-spectrometry/ups1-and-ups2-proteomic.html) :

```{r PCA2, fig.height=12, fig.width=9.5, fig.align="center", echo=TRUE}
# limit to UPS1 
plotPCAw(testPD$datImp[which(testPD$annot[,"SpecType"]=="UPS1"),], sampleGrp=grp9, tit="PCA on ProteomeDiscoverer, UPS1 only (NAs imputed)",rowTyName="proteins", useSymb2=0)

plotPCAw(testMQ$datImp[which(testMQ$annot[,"SpecType"]=="UPS1"),], sampleGrp=grp9, tit="PCA on MaxQuant, UPS1 only (NAs imputed)",rowTyName="proteins", useSymb2=1:9)

```

### PCA Only on UPS1 Proteins

Based on PCA one cane see that the comparison with concentrations >= 250 aMol may be better to actually detect differences, as also confirmed by ROC part later.



## Characteristics of Pairwise Comparisons

A very universal and simple way to analyze data is by checking on several pairwise comparisons, in particular if the experimental setup does not include complete multifactorial plans. 

This [UPS1](https://www.sigmaaldrich.com/life-science/proteomics/mass-spectrometry/ups1-and-ups2-proteomic.html) spike-in experiment has `r ncol(dataPD$quant)` samples organized (according to meta-information) as `r length(grp9)` groups. 
Thus one obtains in total `r ncol(testPD$BH)` comparisons which will make comparisons very crowded.
The publication by Ramus focussed on 3 pairwise comparisons only. Here we'll extend this to 5 pairwise comparisons.


### Pairwise Testing Summary

Thus, the graphical comparisons were restricted to three comparisons presented in the original publication plus two additional ones.
The distribution of intra-group CV-values showed (without major surprise) that the highest UPS1 concentrations replicated best. 
In consequence comparisons using this group are expected to have a decent chance to rather specifically reveil a high number of UPS1 proteins.

```{r pairWise1, echo=TRUE}
## The names of all the pair-wise comparisons possible
colnames(testPD$BH)
```

Now, we'll construct a table showing all possible pairwise-comparisons. Using the function *numPairDeColNames()* we can easily extract the UPS1 concentrations as numeric content and show the (log-)ratio of the pairwise comparisons (column 'log2rat'), the final concentration (in fmol) and the number of differentially abundant proteins passing 5% FDR (using classical Benjamini-Hochberg FDR or lfdr [Strimmer 2008](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-9-303).

```{r pairWise2, echo=TRUE}
## The number of differentially abundant proteins passing 5% FDR (ProteomeDiscoverer and MaxQuant) 
signCount <- cbind( sig.PD.BH=colSums(testPD$BH < 0.05, na.rm=TRUE), sig.PD.lfdr=if("lfdr" %in% names(testPD)) colSums(testPD$lfdr < 0.05, na.rm=TRUE),
  sig.MQ.BH=colSums(testMQ$BH < 0.05, na.rm=TRUE), sig.MQ.lfdr=if("lfdr" %in% names(testMQ)) colSums(testMQ$lfdr < 0.05, na.rm=TRUE) )

table1 <- numPairDeColNames(testPD$BH, stripTxt="amol", sortByAbsRatio=TRUE)
table1 <- cbind(table1, signCount[table1[,1],])
knitr::kable(table1, caption="All pairwise comparisons (extended from Ramus et al)", align="c")
```

You can see that in numerous cases much more than the `r sum(dataMQ$annot[,"SpecType"] =="UPS1")` UPS1 proteins showed up significant.


In the Ramus et al paper only 3 pairwise comparisons were further analyzed :

```{r pairWiseSelect2, echo=TRUE}
## In Ramus paper selection
colnames(testPD$BH)[c(2,21,27)]   
```

Finally, let's use a slightly extended selection of concentrations :

```{r pairWiseSelect3, echo=TRUE}
## extended selection
useCompNo <- c(2,21,27, 14,15)
colnames(testPD$BH)[useCompNo]

## Let's extract the concentration part to numeric
numNamePart <- numPairDeColNames(testPD$BH, selComp=useCompNo, stripTxt="amol", sortByAbsRatio=TRUE)
head(numNamePart)

## table with concentrations in selected comparisons
table2 <- cbind(numNamePart, signCount[numNamePart[,1],])
knitr::kable(table2, caption="Selected pairwise comparisons (extended from Ramus et al)", align="c")
```


### Pairwise Simlarity : Volcano-Plots

Volcano-plots offer more insight in how statistical test results vary in respect to p-values. 
In addition we can mark the different protein-groups (or species), see also vignette to the package [wrGraph](https://CRAN.R-project.org/package=wrGraph).

The PCA plots already told us graphically how strong the differences appear in the various (pairwise) comparisons. 
Counting the number of proteins passing a classical threshold for differential expression is a good way to start.

The dataset contains 9 different levels of [UPS1](https://www.sigmaaldrich.com/life-science/proteomics/mass-spectrometry/ups1-and-ups2-proteomic.html) concentrations, in consequence 36 pair-wise comparisons are possible in the data-set from [Ramus et al 2016](https://doi.org/10.1016/j.jprot.2015.11.011).
Plotting all these pair-wise comparisons would make way too crowded plots.

```{r Volcano0, echo=TRUE}
## the selected comparisons to check
cbind(no=useCompNo, name=colnames(testPD$t)[useCompNo])
```

```{r Volcano1, fig.height=16, fig.width=9.5, fig.align="center", echo=TRUE}
## check presence and good version of package wrGraph
doVolc <- requireNamespace("wrGraph", quietly=TRUE)
if(doVolc) doVolc <- packageVersion("wrGraph") >= "1.0.6"

## ProteomeDiscoverer
layout(matrix(1:6, ncol=2)) 
if(doVolc) {
  for(i in useCompNo) VolcanoPlotW(testPD, useComp=i, FCthrs=2, FdrThrs=0.05, annColor=c(4,2,3),silent=TRUE)}
```

```{r Volcano2, fig.height=16, fig.width=9.5, fig.align="center", echo=TRUE}
## MaxQuant
layout(matrix(1:6, ncol=2))
if(doVolc) {
  for(i in useCompNo) VolcanoPlotW(testMQ, useComp=i, FCthrs=2, FdrThrs=0.05, annColor=c(4,2,3),silent=TRUE)}
```

Typically a classical proteomics analysis would go from this step into further investigating proteins with significant abundances.
However, the UPS1 setup is special since we know in advance which proteins should be differential.
In the following section we'll focus on these UPS1 proteins and we'll take advantage of the fact that multiple concentrations thereof have been measured.



## UPS1: Characteristics of the Data for the Spike-In Proteins (after NA-Imputation)

We know from the experimental setup that there were 48 UPS1 proteins proteins present in the commercial mix. 
The lowest concentrations are extremely challenging and it is no surprise that many of them were not detected at the lowest concentrations.
In order to choose among the various concentrations of [UPS1](https://www.sigmaaldrich.com/life-science/proteomics/mass-spectrometry/ups1-and-ups2-proteomic.html), let's look how many NAs are in each group of replicates, and in particular, the number of NAs among the UPS1 proteins.

```{r nNA2, echo=TRUE} 
## The number of NAs, just the UPS1 proteins (in ProteomeDiscoverer):
sumNAperGroup(dataPD$raw[which(dataPD$annot[,"SpecType"]=="species2"),], grp9) 
sumNAperGroup(dataMQ$raw[which(dataMQ$annot[,"SpecType"]=="species2"),], grp9) 

```

As general indicator for data-quality and -usability let's look at the intra-replicate variability. 
Here we plot all intra-group (ie UPS1-concentration) CVs.

In the figure below the complete series (including yeast) is shown on the left side, the human UPS1 proteins only on the right side.
Briefly, vioplots show a kernel-estimate for the distribution, in addition, a box-plot is also integrated (see vignette to package [wrGraph](https://CRAN.R-project.org/package=wrGraph)).

```{r intraReplicCV1, fig.height=12, fig.width=10, fig.align="center", echo=TRUE}
## combined plot : all data (left), Ups1 (right)
layout(1:2)
sumNAinPD <- list(length=18)
sumNAinPD[2*(1:length(unique(grp9))) -1] <- as.list(as.data.frame(log2(rowGrpCV(testPD$datImp, grp9))))
sumNAinPD[2*(1:length(unique(grp9))) ] <- as.list(as.data.frame(log2(rowGrpCV(testPD$datImp[which(testPD$annot[,"SpecType"]=="UPS1"),], grp9))))
names(sumNAinPD)[2*(1:length(unique(grp9))) -1] <-  sub("amol","",unique(grp9))
names(sumNAinPD)[2*(1:length(unique(grp9))) ] <- paste(sub("amol","",unique(grp9)),"Ups",sep=".")
vioplotW(sumNAinPD, halfViolin="pairwise", tit="CV Intra Replicate, ProteomeDiscoverer", cexNameSer=0.6) 
mtext("left part : all data\nright part: UPS1",adj=0,cex=0.8)

sumNAinMQ <- list(length=18)
sumNAinMQ[2*(1:length(unique(grp9))) -1] <- as.list(as.data.frame(log2(rowGrpCV(testMQ$datImp, grp9))))
sumNAinMQ[2*(1:length(unique(grp9))) ] <- as.list(as.data.frame(log2(rowGrpCV(testMQ$datImp[which(testMQ$annot[,"SpecType"]=="UPS1"),], grp9))))
names(sumNAinMQ)[2*(1:length(unique(grp9))) -1] <- sub("amol","",unique(grp9))                        # paste(unique(grp9),"all",sep=".")
names(sumNAinMQ)[2*(1:length(unique(grp9))) ] <- paste(sub("amol","",unique(grp9)),"Ups",sep=".")      #paste(unique(grp9),"Ups1",sep=".")
vioplotW(sumNAinMQ, halfViolin="pairwise", tit="CV intra replicate, MaxQuant",cexNameSer=0.6) 
mtext("left part : all data\nright part: UPS1",adj=0,cex=0.8)

## decent compromise based on CV : focus on 250 amol  vs 50000 amol
##    ... or for low no of NAs:           2500 amol   vs 50000 amol

 ## for linear modeling rather  500 amol  vs 50000 amol (last of 'high' NA counts)
 
## Ramus:  500  vs  50000    (PD 28/0 NA, MQ 97/1 NA)
##        5000  vs  50000    (PD  0/0 NA, MQ  8/1 NA)
##       12500  vs  25000
```

Once can see that lower concentrations of UPS1 usually have worse CV (coefficient of variance) in the respective samples, 
this phenomenon also correlates with the content of NAs in the original data.



### Testing All Individual UPS1 Proteins By Linear Regression

```{r linModel0, fig.height=17, fig.width=9.5, fig.align="center", echo=TRUE}
## the quantified UPS1 names
table(dataPD$annot[,"SpecType"])              # 46
table(dataMQ$annot[,"SpecType"])              # 48

## extract names of quantified UPS1-proteins
NamesUpsPD <- dataPD$annot[which(dataPD$annot[,"SpecType"]=="UPS1"),"Accession"]
NamesUpsMQ <- dataMQ$annot[which(dataMQ$annot[,"SpecType"]=="UPS1"),"Accession"]

```


Run linear models, extract slope & pval, plot per UPS1 protein :

```{r linModelPD, fig.height=17, fig.width=9.5, fig.align="center", echo=TRUE}
## ProteomeDiscoverer
lmPD <- list(length=length(NamesUpsPD))

layout(matrix(1:12, ncol=2))
lmPD[1:12] <- lapply(NamesUpsPD[1:12], linModelSelect, dat=dataPD, expect=grp9, startLev=1:5, cexXAxis=0.7, logExpect=TRUE, silent=TRUE)
lmPD[13:24] <- lapply(NamesUpsPD[13:24], linModelSelect, dat=dataPD, expect=grp9, startLev=1:5, cexXAxis=0.7, logExpect=TRUE, silent=TRUE)
lmPD[25:36] <- lapply(NamesUpsPD[25:36], linModelSelect, dat=dataPD, expect=grp9, startLev=1:5, cexXAxis=0.7, logExpect=TRUE, silent=TRUE)
lmPD[37:46] <- lapply(NamesUpsPD[37:46], linModelSelect, dat=dataPD, expect=grp9, startLev=1:5, cexXAxis=0.7, logExpect=TRUE, silent=TRUE)
names(lmPD) <- NamesUpsPD
```

```{r linModelPD2, fig.height=17, fig.width=9.5, fig.align="center", echo=TRUE}
## We make a little summary of regression-results (ProteomeDiscoverer)
lmPDsum <- cbind(pVal=sapply(lmPD,function(x) x$coef[2,4]),logp=NA,slope=sapply(lmPD,function(x) x$coef[2,1]), startFr=sapply(lmPD,function(x) x$startLev), medRawAbund=apply(log2(dataPD$raw[NamesUpsPD,]),1,median,na.rm=TRUE),good=0)

lmPDsum[,"logp"] <- log10(lmPDsum[,"pVal"])
lmPDsum[which(lmPDsum[,"logp"] < -12 & lmPDsum[,"slope"] >0.75),"good"] <- 1
lmPDsum[which(lmPDsum[,"logp"] < -10 & lmPDsum[,"slope"] >0.7),"good"] <- lmPDsum[which(lmPDsum[,"logp"] < -10 & lmPDsum[,"slope"] >0.7),"good"]+ 1

## now we can check the number of high-confidence quantifications (0 means bad linear model) 
table(lmPDsum[,"good"])           # 24 good quantifications

## at which concentration of UPS1 did one et the best regression results ?
table(lmPDsum[,"startFr"])        # most starting at 1

## a brief summary/overview of regression-results
summary(lmPDsum)
```


```{r linModelMQ, fig.height=17, fig.width=9.5, fig.align="center", echo=TRUE}
## Now for MaxQuant
lmMQ <- list(length=length(NamesUpsMQ))

layout(matrix(1:12, ncol=2))
lmMQ[1:12] <- lapply(NamesUpsMQ[1:12], linModelSelect, dat=dataMQ, expect=grp9, startLev=1:5, cexXAxis=0.7, logExpect=TRUE, silent=TRUE)
lmMQ[13:24] <- lapply(NamesUpsMQ[13:24], linModelSelect, dat=dataMQ, expect=grp9, startLev=1:5, cexXAxis=0.7, logExpect=TRUE, silent=TRUE)
lmMQ[25:36] <- lapply(NamesUpsMQ[25:36], linModelSelect, dat=dataMQ, expect=grp9, startLev=1:5, cexXAxis=0.7, logExpect=TRUE, silent=TRUE)
lmMQ[37:48] <- lapply(NamesUpsMQ[37:48], linModelSelect, dat=dataMQ, expect=grp9, startLev=1:5, cexXAxis=0.7, logExpect=TRUE, silent=TRUE)
names(lmMQ) <- NamesUpsMQ
```

```{r linModelMQ2, fig.height=17, fig.width=9.5, fig.align="center", echo=TRUE}
## We make a little summary of regression-results (MaxQuant)
## Regressions with bad slope and/or p-value will be marked as O
lmMQsum <- cbind(pVal=sapply(lmMQ,function(x) x$coef[2,4]),logp=NA,slope=sapply(lmMQ,function(x) x$coef[2,1]), startFr=sapply(lmMQ,function(x) x$startLev), medRawAbund=apply(log2(dataMQ$raw[NamesUpsMQ,]),1,median,na.rm=TRUE),good=0)
lmMQsum[,"logp"] <- log10(lmMQsum[,"pVal"])
lmMQsum[which(lmMQsum[,"logp"] < -12 & lmMQsum[,"slope"] >0.75),"good"] <- 1
lmMQsum[which(lmMQsum[,"logp"] < -10 & lmMQsum[,"slope"] >0.7),"good"] <- lmMQsum[which(lmMQsum[,"logp"] < -10 & lmMQsum[,"slope"] >0.7),"good"]+ 1

## now we can check the number of high-confidence quantifications (0 means bad linear model) 
table(lmMQsum[,"good"])           # 26 good quantifications

## at which concentration of UPS1 did one et the best regression results ?
table(lmMQsum[,"startFr"])        # most starting at 5 !

## a brief summary/overview of regression-results
summary(lmMQsum)
```

Next, we can compare the different modelizations on a global basis :

```{r linModelPlot1, fig.height=12, fig.width=9.5, fig.align="center", echo=TRUE}
## summary graphics on all indiv protein regressions for ProteomeDiscoverer
layout(matrix(c(1:3,3), ncol=2, byrow=TRUE))
hist(log10(sapply(lmPD,function(x) x$coef[2,4])), br=15,las=1, main="PD: hist of regr p-values",xlab="log10 p-values")     # good p < 1e-12
hist( sapply(lmPD,function(x) x$coef[2,1]), br=15,las=1, main="PD: hist of regr slopes",xlab="slope")     # good 

tit <- "ProteomeDiscoverer, UPS1 regressions :  p-value vs slope"
useCol <- colorAccording2(lmPDsum[,"medRawAbund"], gradTy="rainbow", revCol=TRUE, nEndOmit=14)
plot(lmPDsum[,c(2,3)], main=tit, type="n")   #col=1, bg.col=useCol, pch=20+lmPDsum[,"startFr"],
points(lmPDsum[,c(2,3)], col=1, bg=useCol, pch=20+lmPDsum[,"startFr"],)
legend("topright",paste("best starting from ",1:5), text.col=1, pch=21:25, col=1, pt.bg="white", cex=0.9, xjust=0.5, yjust=0.5)
mtext("fill color according to median (raw) abundance (violet/blue/low -> green -> red/high)",cex=0.9)
  abline(v=c(-12,-10),lty=2,col="grey") ; abline(h=c(0.7,0.75),lty=2,col="grey")

hi1 <- hist(lmPDsum[,"medRawAbund"], plot=FALSE)
legendHist(sort(lmPDsum[,5]), colRamp=useCol[order(lmPDsum[,"medRawAbund"])][cumsum(hi1$counts)], location="bottomleft", legTit="median raw abundance")  #

```

ProteomeDiscoverer has bimodial character in histogram of slopes and p-values (not as clear) : apr 50% of proteins got well quantified others very bad.


```{r linModelPlot2, fig.height=12, fig.width=9.5, fig.align="center", echo=TRUE}
## now for MaxQuant
layout(matrix(c(1:3,3), ncol=2, byrow=TRUE))
hist(log10(sapply(lmMQ,function(x) x$coef[2,4])), br=15,las=1, main="MQ: hist of regr p-values",xlab="log10 p-values")     # good p < 1e-12
hist( sapply(lmMQ,function(x) x$coef[2,1]), br=15,las=1, main="MQ: hist of regr slopes",xlab="slope")     # good 

tit <- "MaxQuant, UPS1 regressions :  p-value vs slope"
useCol <- colorAccording2(lmMQsum[,"medRawAbund"], gradTy="rainbow", revCol=TRUE, nEndOmit=14)
plot(lmMQsum[,c(2,3)], main=tit, type="n")   #col=1, bg.col=useCol, pch=20+lmMQsum[,"startFr"],
points(lmMQsum[,c(2,3)], col=1, bg=useCol, pch=20+lmMQsum[,"startFr"],)
legend("topright",paste("best starting from ",1:5), text.col=1, pch=21:25, col=1, pt.bg="white", cex=0.9, xjust=0.5, yjust=0.5)
mtext("fill color according to median (raw) abundance (red/high -> blue/low)",cex=0.9)
  abline(v=c(-12,-10),lty=2,col="grey") ; abline(h=c(0.7,0.75),lty=2,col="grey") 

hi1 <- hist(lmMQsum[,"medRawAbund"], plot=FALSE)
legendHist(sort(lmMQsum[,5]), colRamp=useCol[order(lmMQsum[,"medRawAbund"])][cumsum(hi1$counts)], location="bottomleft", legTit="median raw abundance")  

```
MaxQuant : No bimodial distributions for p-values or slopes, regressions appear raher uniform with high slopes using only the last few concentrations !


## Comparison Using ROC-Curves

ROC curves display Sensitivity (True Positive Rate) versus 1-Specificity (False Positive Rate). 
They are typically used as illustrate and compare the discriminiative capacity of a yes/no decision system, see eg also [ROC on Wikipedia](https://en.wikipedia.org/wiki/Receiver_operating_characteristic) or the original publication [Hand and Till 2001](https://doi.org/doi:10.1023/A:1010920819831).  
In this case ROC curves are used to judge how well heterologous human [UPS1 proteins](https://www.sigmaaldrich.com/life-science/proteomics/mass-spectrometry/ups1-and-ups2-proteomic.html) can be recognized as differential abundant while constant yeast matrix proteins should not get classified as differential.  Finally, ROC curves let us also gain some additional insights if the commonly used 5-percent FDR threshld cutoff allows getting the best out of the testing system.

The [Ramus et al 2016](https://doi.org/10.1016/j.jprot.2015.11.011) -dataset contains 9 different levels of UPS1 concentrations, in consequence 36 pair-wise comparisons are possible.
Plotting all these pair-wise comparisons would make way too crowded plots.

Thus, the graphical comparisons were restricted to three comparisons presented in the original publication by [Ramus et al 2016](https://doi.org/10.1016/j.jprot.2015.11.011) plus two additional ones.
The distribution of intra-group CV-values showed (without major surprise) that the highest UPS1 concentrations replicated best. 
In consequence comparisons using this group are expected to have a decent chance to rather specifically reveil a high number of UPS1 proteins.



### ROC for Single Pair

Initially a ROC-curve cat get calculated for each pair-wise comparison where it is known which proteins should be found differential (ie human UPS1 proteins).
```{r ROC_single1, echo=TRUE}
## single comparison data for ROC
rocPD.2 <- summarizeForROC(testPD, annotCol="SpecType", spec=c("Yeast","UPS1"), columnTest=2, tyThr="BH",overl=F,color=5)       # 12500amol-25000amol
tail(signif(rocPD.2,3))
```


### ROC for Multiple Pairs

However, since we're treating a larger data-set this can be done in batch.
Now we are ready to extract all counts of each UPS1 for constructing ROC-curves.
```{r ROC_main1, echo=TRUE}

layout(1)
rocPD <- lapply(table2[,1],function(x) summarizeForROC(testPD, annotCol="SpecType", spec=c("Yeast","UPS1"), columnTest=x, tyThr="BH", plotROC=FALSE))
rocMQ <- lapply(table2[,1],function(x) summarizeForROC(testMQ, annotCol="SpecType", spec=c("Yeast","UPS1"), columnTest=x, tyThr="BH", plotROC=FALSE))

names(rocPD) <- colnames(testPD$BH)[useCompNo] 
names(rocMQ) <- colnames(testMQ$BH)[useCompNo] 
```


And we can plot the ROC curves for ProteomeDiscoverer :

```{r ROC_PD1, fig.height=9, fig.width=9.5, fig.align="center", echo=TRUE}
layout(1)
colPanel <- 2:6                                              #c(grey(0.4),2:5)
methNa <- paste(table2[,1],", ie",table2[,3],"-",table2[,4])
methNa <- paste0(rep(c("PD","MQ"), each=length(useCompNo)), methNa)
plotROC(rocPD[[1]],rocPD[[2]],rocPD[[3]],rocPD[[4]],rocPD[[5]], col=colPanel, methNames=methNa[1:5], pointSi=0.8, tit="ProteomeDiscoverer at 5 ratios",legCex=1)
```

One can see form the figure, that the classical threshold of FDR=0.05 suggests in this case to cut not at the optimal point, 
lower threshod values would provide a (slightly) better compromise between specificity & sensitivty.

We can see that the comparison 12500 amol vs  25000 amol performed worse than the other ones. 
Although at these high UPS1 concentrations the proteins were well detected, the statistical test had more problems just calling the UPS1 proteins 'differential'.
At the other comparisons the (theoretical) ratio was much higher :


Let's moove on with the ROC curves for MaxQuant :

```{r ROC_MQ1, fig.height=9, fig.width=9.5, fig.align="center", echo=TRUE}
plotROC(rocMQ[[1]],rocMQ[[2]],rocMQ[[3]],rocMQ[[4]],rocMQ[[5]], col=colPanel, methNames=methNa[6:10], pointSi=0.8, xlim=c(0,0.27),txtLoc=c(0.09,0.3,0.03), tit="MaxQuant selected ratios",legCex=1)
```

Please note, that instead of 5 curves only 4 are shown : The comparison of 12500 vs 25000 gave not even a single UPS1 protein as 'sinificant'. 
Thus, the true positives (TP) never left the count of 0, in consequence specificity and sensitivity can't be calculated.

And the ROC curves for both ProteomeDiscoverer and MaxQuant :

```{r ROC_PD+MQ, fig.height=9, fig.width=9.5, fig.align="center", echo=TRUE}

colPan10 <- rainbow(13)[c(-3,-5,-13)]
plotROC(rocPD[[1]],rocPD[[2]],rocPD[[3]],rocPD[[4]],rocPD[[5]], rocMQ[[1]],rocMQ[[2]],rocMQ[[3]],rocMQ[[4]],rocMQ[[5]], col=colPan10, methNames=methNa, pointSi=0.8, tit="PD and MQ at selected ratios",legCex=1)
```

More quantitation methods will get integrated shortly ...
```{r ROC_PL1, echo=FALSE}
## shifted for not printing
## Proline
statusPL <- NULL
```



## Acknowledgements
The author wants to acknowledge the support by the [IGBMC](http://www.igbmc.fr/) (CNRS UMR 7104, Inserm U 1258), [CNRS](http://www.cnrs.fr/), [IGBMC](http://www.igbmc.fr/), [Universite de Strasbourg](https://www.unistra.fr) and [Inserm](https://www.inserm.fr/) and of course my collegues from the [IGBMC proteomics platform](http://proteomics.igbmc.fr/).
Furthermore, many very fruitful discussions with colleages on national and international level have helped to formulate ideas, improve and disseminate the tools presented here.



## Session-Info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
